#!/usr/bin/env python

"""
Detects Ryan Castellucci's Asymmetric Curve25519 backdoor for RSA key generation algorithms: https://gist.github.com/ryancdotorg/9bd3873e488740f86ebb
For more information, see: https://github.com/samvartaka/crypto_backdoors/tree/master/rsa_curve25519/README.md

Copyright (C) 2015 - Jos Wetzels
See the file 'LICENSE' for copying permission.
"""

import sys
from binascii import unhexlify
from M2Crypto import X509
from Crypto.Util import number

# Curve25519 is defined over prime field defined by p = 2^255 - 19
CURVE_P = (2**255 - 19)

# Compute Legendre symbol a|p
def legendre_symbol(a, p):
    ls = pow(a, (p - 1) / 2, p)
    return -1 if ls == p - 1 else ls

# Compute modular square root using Tonelli-Shanks algorithm
# Taken from http://samuelkerr.com/?p=431
def modular_sqrt(a, p):
    # Simple cases
    if legendre_symbol(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return n
    elif p % 4 == 3:
        return pow(a, (p + 1) / 4, p)

    # Partition p-1 to s * 2^e for an odd s (i.e. reduce all the powers of 2 from p-1)
    s = p - 1
    e = 0
    while s % 2 == 0:
        s /= 2
        e += 1

    # Find some 'n' with a legendre symbol n|p = -1.
    n = 2
    while legendre_symbol(n, p) != -1:
        n += 1

    # x is a guess of the square root that gets better with each iteration.
    # b is the "fudge factor"
    # g is used for successive powers of n to update both a and b
    # r is the exponent - decreases with each update
    x = pow(a, (s + 1) / 2, p)
    b = pow(a, s, p)
    g = pow(n, s, p)
    r = e

    while True:
        t = b
        m = 0
        for m in xrange(r):
            if t == 1:
                break
            t = pow(t, 2, p)

        if m == 0:
            return x

        gs = pow(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m

# Evaluate curve over candidate x-coordinate
def do_curve(x):
	return ((x**3 + 486662*(x**2) + x) % CURVE_P)

# Determines whether a candidate x-coordinate belongs to a valid point (x,y) on Curve25519
def is_on_curve(x_candidate):
	x = number.bytes_to_long(x_candidate[::-1])
	y2 = do_curve(x)
	y = modular_sqrt(y2, CURVE_P)
	return ((y**2 % CURVE_P) == y2)

# Determine probability with which RSA public keys were generated by backdoor
def backdoor_probability(pubkey_candidates):
	# Iterate over candidates and test if they are valid curve-point x-coordinates
	for candidate in pubkey_candidates:
		# If there exists a candidate which is not a valid curve-point x-coordinate, these keys cannot have been generated by backdoor
		if not(is_on_curve(candidate)):
			return 0

	# If all candidates are valid curve-point x-coordinates, determine probability with which RSA keys were generated by backdoor (1 minus probability they were generated by a clean algorithm)
	return 1-(0.5**len(pubkey_candidates))

# Recover ephemeral Curve25519 public key candidate from RSA public key embedded in certificate
def recover_ephemeral_pubkey(cert_file, pos=80):
	x509 = X509.load_cert(cert_file)
	modulus = unhexlify(x509.get_pubkey().get_modulus())
	ephem_pub_candidate = modulus[pos:pos+32]
	return ephem_pub_candidate

if (len(sys.argv) < 2):
	raise Exception("[-]Usage: %s <keyfilename>" % sys.argv[0])

keyfilename = sys.argv[1]

pubkey_candidates = []
for i in xrange(1,11):
	pubkey_candidates.append(recover_ephemeral_pubkey(("./%s%d.crt" % (keyfilename, i))))

probability = backdoor_probability(pubkey_candidates)
print "[+]RSA public keys generated by backdoor with probability %f" % probability